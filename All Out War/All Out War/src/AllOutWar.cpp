/*
-----------------------------------------------------------------------------
Filename:    AllOutWar.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.8.x Application Wizard for VC10 (May 2012)
      https://bitbucket.org/jacmoe/ogreappwizards
-----------------------------------------------------------------------------
*/

#include "AllOutWar.h"

//-------------------------------------------------------------------------------------
AllOutWar::AllOutWar(void)
{
}
//-------------------------------------------------------------------------------------
AllOutWar::~AllOutWar(void)
{
}
void AllOutWar::destroyScene(void)
{
}
void AllOutWar::createFrameListener(void)
{
    BaseApplication::createFrameListener();
}
//-------------------------------------------------------------------------------------
void AllOutWar::createScene(void)
{
	mImage.load("t1.png",Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	Graph* graph = new Graph();
	mHeightMap = new Height_Map(mImage.getWidth() - 1,mImage.getHeight() - 1,graph);
	const int Width = mImage.getWidth();
	const int Height = mImage.getHeight();
	float Edgelength = 20;
	int type = 0;
	for(int w = 0; w < (Width - 1); w++)
	{
		for(int h = 0; h < (Height - 1); h++)
		{
			Physics::Vector Pos[4];
			GroundType Col[4];
			Ogre::ColourValue image = mImage.getColourAt(w,h,0);
			Pos[0] = Physics::Vector( w * Edgelength, (image.r * 400) + (image.b * 4000), h * Edgelength);
			Col[0] = static_cast<GroundType>(int(image.g * 255));

			image = mImage.getColourAt((w + 1),h,0);
			Pos[1] = Physics::Vector( (w + 1) * Edgelength, (image.r * 400) + (image.b * 4000) , h * Edgelength);
			Col[1] =static_cast<GroundType>(int(image.g * 255));

			image = mImage.getColourAt(w,(h + 1),0);
			Pos[2] = Physics::Vector( w * Edgelength, (image.r * 400) + (image.b * 4000), (h + 1) * Edgelength);
			Col[2] =static_cast<GroundType>(int(image.g * 255));

			image = mImage.getColourAt((w + 1),(h + 1),0);
			Pos[3] = Physics::Vector( (w + 1) * Edgelength, (image.r * 400) + (image.b * 4000), (h + 1) * Edgelength);
			Col[3] = static_cast<GroundType>(int(image.g * 255));

			mHeightMap->SetNodes(w,h,Pos,Col, type,mSceneMgr);
			type++;
		}
	}	
	for(int x = 0; x < (Width - 1); x++)
	{
		for(int y = 0; y < (Height - 1); y ++)
		{
			mHeightMap->INITEdges(x,y);
		}
	}	
	mFactory = mFactory->getInstance(mSceneMgr,mHeightMap,graph);
	mSceneMgr->setAmbientLight(Ogre::ColourValue(0.8,0.8,0.8));
	mSceneMgr->setSkyDome(true, "Examples/CloudySky",5,8);
	mPlayer = new Player(mSceneMgr,mHeightMap, mCamera, mWindow->getWidth(), mWindow->getHeight());
	mFactions.Push_Back(mPlayer);
}
bool AllOutWar::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	mFactory->Update(evt.timeSinceLastFrame);
	for(ListIterator<Faction* > iter(&mFactions); !iter.IsNuLL();iter++)
	{
		iter.Value()->Update(evt.timeSinceLastFrame);
	}
	return BaseApplication::frameRenderingQueued(evt);
}
bool AllOutWar::keyPressed( const OIS::KeyEvent &arg )
{
	mPlayer->injectKeyDown(arg);
	return BaseApplication::keyPressed(arg);
}
bool AllOutWar::keyReleased( const OIS::KeyEvent &arg )
{
	mPlayer->injectKeyUp(arg);
	return true;
}
bool AllOutWar::mouseMoved( const OIS::MouseEvent &arg )
{
	mPlayer->injectMouseMove(arg);
	return BaseApplication::mouseMoved(arg);
}
bool AllOutWar::mousePressed( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
{
	mPlayer->injectMouseDown(arg,id);
	return true;
}
bool AllOutWar::mouseReleased( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
{
	mPlayer->injectMouseUp(arg,id);
	return true;
}



#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        AllOutWar app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
